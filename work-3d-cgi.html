<!DOCTYPE html>
<html lang="en">

<head>
    <title>3D & CGI Work | Aditya Chitoshiya</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="author" content="Antoine BERNIER (abernier)" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            color: white;
            background-color: #050505;
            margin: 0;
            overflow: hidden;
            font-family: 'Space Grotesk', sans-serif;
        }

        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            text-decoration: none;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
            pointer-events: auto;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Loading Screen */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #050505;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            transition: opacity 0.5s ease-out;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: #3b82f6;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            color: #3b82f6;
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="spinner"></div>
        <div class="loading-text">Loading 3D Scene...</div>
    </div>

    <a href="work.html" class="back-btn">‚Üê Back to Work</a>

    <!-- hidden credits: 
        Three.js - webgl - inverse kinematics
        Character model by Aki (Unity Asset Store), furnitures from poly.pizza, scene by abernier. CC0.
        -->

    <script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
				"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
			}
		}
		</script>

    <script type="module">
        import * as THREE from 'three';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { CCDIKSolver, CCDIKHelper } from 'three/addons/animation/CCDIKSolver.js';
        import Stats from 'three/addons/libs/stats.module.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        let scene, camera, renderer, orbitControls, transformControls;
        let mirrorSphereCamera;

        const OOI = {};
        let IKSolver;

        let stats, gui, conf;
        const v0 = new THREE.Vector3();

        init();

        async function init() {

            conf = {
                followSphere: false,
                turnHead: true,
                ik_solver: true,
                update: updateIK
            };

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, .17);
            scene.background = new THREE.Color(0x050505);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.001, 5000);
            camera.position.set(0.9728517749133652, 1.1044765132727201, 0.7316689528482836);
            camera.lookAt(scene.position);

            const ambientLight = new THREE.AmbientLight(0xffffff, 8); // soft white light
            scene.add(ambientLight);

            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
            const gltfLoader = new GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);

            try {
                // Using the official three.js example model URL
                const gltf = await gltfLoader.loadAsync('https://threejs.org/examples/models/gltf/kira.glb');
                gltf.scene.traverse(n => {

                    if (n.name === 'head') OOI.head = n;
                    if (n.name === 'lowerarm_l') OOI.lowerarm_l = n;
                    if (n.name === 'Upperarm_l') OOI.Upperarm_l = n;
                    if (n.name === 'hand_l') OOI.hand_l = n;
                    if (n.name === 'target_hand_l') OOI.target_hand_l = n;

                    if (n.name === 'boule') OOI.sphere = n;
                    if (n.name === 'Kira_Shirt_left') OOI.kira = n;

                });
                scene.add(gltf.scene);

                const targetPosition = OOI.sphere.position.clone(); // for orbit controls
                OOI.hand_l.attach(OOI.sphere);

                // mirror sphere cube-camera
                const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);
                mirrorSphereCamera = new THREE.CubeCamera(0.05, 50, cubeRenderTarget);
                scene.add(mirrorSphereCamera);
                const mirrorSphereMaterial = new THREE.MeshBasicMaterial({ envMap: cubeRenderTarget.texture });
                OOI.sphere.material = mirrorSphereMaterial;

                OOI.kira.add(OOI.kira.skeleton.bones[0]);
                const iks = [
                    {
                        target: 22, // "target_hand_l"
                        effector: 6, // "hand_l"
                        links: [
                            {
                                index: 5, // "lowerarm_l"
                                rotationMin: new THREE.Vector3(1.2, - 1.8, - .4),
                                rotationMax: new THREE.Vector3(1.7, - 1.1, .3)
                            },
                            {
                                index: 4, // "Upperarm_l"
                                rotationMin: new THREE.Vector3(0.1, - 0.7, - 1.8),
                                rotationMax: new THREE.Vector3(1.1, 0, - 1.4)
                            },
                        ],
                    }
                ];
                IKSolver = new CCDIKSolver(OOI.kira, iks);
                const ccdikhelper = new CCDIKHelper(OOI.kira, iks, 0.01);
                scene.add(ccdikhelper);

                // Hide loading screen when ready
                const loadingScreen = document.getElementById('loading');
                if (loadingScreen) {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500);
                }

            } catch (error) {
                console.error("Error loading model:", error);
                const loadingText = document.querySelector('.loading-text');
                if (loadingText) loadingText.textContent = "Error loading model. Refresh to retry.";
                if (loadingText) loadingText.style.color = "red";
            }

            gui = new GUI();
            gui.add(conf, 'followSphere').name('follow sphere');
            gui.add(conf, 'turnHead').name('turn head');
            gui.add(conf, 'ik_solver').name('IK auto update');
            gui.add(conf, 'update').name('IK manual update()');
            gui.open();

            //

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            document.body.appendChild(renderer.domElement);

            //

            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.minDistance = 0.2;
            orbitControls.maxDistance = 1.5;
            orbitControls.enableDamping = true;
            // orbitControls.target.copy( targetPosition ); 

            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.size = 0.75;
            transformControls.showX = false;
            transformControls.space = 'world';

            // Only attach if model loaded successfully
            if (OOI.target_hand_l) {
                transformControls.attach(OOI.target_hand_l);
            }
            scene.add(transformControls.getHelper());

            // disable orbitControls while using transformControls
            transformControls.addEventListener('mouseDown', () => orbitControls.enabled = false);
            transformControls.addEventListener('mouseUp', () => orbitControls.enabled = true);

            //

            stats = new Stats();
            document.body.appendChild(stats.dom);

            window.addEventListener('resize', onWindowResize, false);

        }

        function animate() {

            if (OOI.sphere && mirrorSphereCamera) {

                OOI.sphere.visible = false;
                OOI.sphere.getWorldPosition(mirrorSphereCamera.position);
                mirrorSphereCamera.update(renderer, scene);
                OOI.sphere.visible = true;

            }

            if (OOI.sphere && conf.followSphere) {

                // orbitControls follows the sphere
                OOI.sphere.getWorldPosition(v0);
                orbitControls.target.lerp(v0, 0.1);

            }

            if (OOI.head && OOI.sphere && conf.turnHead) {

                // turn head
                OOI.sphere.getWorldPosition(v0);
                OOI.head.lookAt(v0);
                OOI.head.rotation.set(OOI.head.rotation.x, OOI.head.rotation.y + Math.PI, OOI.head.rotation.z);

            }

            if (conf.ik_solver) {

                updateIK();

            }

            orbitControls.update();
            renderer.render(scene, camera);

            stats.update(); // fps stats

        }

        function updateIK() {

            if (IKSolver) IKSolver.update();

            scene.traverse(function (object) {

                if (object.isSkinnedMesh) object.computeBoundingSphere();

            });

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }
    </script>
</body>

</html>